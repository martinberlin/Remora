{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./node_modules/midi-file/index.js","webpack:///./src/Header.ts","webpack:///./src/BinarySearch.ts","webpack:///./src/ControlChange.ts","webpack:///./src/Midi.ts","webpack:///./node_modules/midi-file/lib/midi-parser.js","webpack:///./node_modules/midi-file/lib/midi-writer.js","webpack:///./src/Encode.ts","webpack:///./node_modules/array-flatten/array-flatten.js","webpack:///./src/Track.ts","webpack:///./src/ControlChanges.ts","webpack:///./src/Instrument.ts","webpack:///./src/InstrumentMaps.ts","webpack:///./src/Note.ts"],"names":["root","factory","exports","module","define","amd","a","i","self","this","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","parseMidi","writeMidi","BinarySearch_1","privatePPQMap","WeakMap","keySignatureKeys","Header","midiData","_this","tempos","timeSignatures","keySignatures","meta","set","header","ticksPerBeat","tracks","forEach","event","type","push","ticks","absoluteTime","timeSignature","numerator","denominator","bpm","microsecondsPerBeat","scale","text","update","currentTime","lastEventBeats","sort","b","index","lastBPM","beats","ppq","elapsedSeconds","time","lastEvent","elapsedMeasures","measures","ticksToSeconds","search","tempo","tempoTime","elapsedBeats","ticksToMeasures","timeSigEvent","secondsToTicks","seconds","Math","round","toJSON","map","fromJSON","json","assign","setTempo","array","prop","beginning","len","length","end","midPoint","floor","event_1","nextEvent","insert","splice","controlChangeNames","1","2","4","5","7","8","10","64","65","66","67","68","84","controlChangeIds","keys","reduce","obj","privateHeaderMap","privateCCNumberMap","ControlChange","controllerType","number","midi_file_1","Encode_1","Header_1","Track_1","Midi","midiArray","ArrayBuffer","Uint8Array","track","currentTicks","deltaTime","trackData","Track","format","duration","shift","fromUrl","url","fetch","response","_a","sent","ok","arrayBuffer","Error","durations","max","apply","durationTicks","addTrack","undefined","toArray","encode","trackJSON","clone","midi","parseTrack","data","lastEventTypeByte","Parser","events","eof","readEvent","readVarInt","eventTypeByte","readUInt8","readBytes","metatypeByte","stream","readUInt16","readString","channel","port","readUInt24","hourByte","frameRate","0","32","96","hour","min","sec","frame","subFrame","metronome","thirtyseconds","readInt8","param1","running","eventType","noteNumber","velocity","byte9","amount","programNumber","buffer","bufferLen","pos","result","u","readInt16","readInt24","readUInt32","bytes","slice","String","fromCharCode","readChunk","id","headerChunk","numTracks","timeDivision","framesPerSecond","ticksPerFrame","parseHeader","trackChunk","writeTrack","w","opts","Writer","writeEvent","useByte9ForNoteOff","writeChunk","writeVarInt","writeUInt8","writeUInt16","writeString","writeUInt24","24","25","29","30","log","LN2","writeInt8","writeBytes","value14","lsb14","msb14","v","b0","b1","writeInt16","b2","writeInt24","writeUInt32","b3","writeInt32","arr","concat","Array","str","codePointAt","reverse","h","writeHeader","flatten","encodeNotes","notes","note","noteOffVelocity","encodeNote","encodeControlChange","cc","encodeInstrument","instrument","keySig","keyIndex","indexOf","encodeKeySignature","e","textEvent","encodeTempo","timeSig","encodeTimeSignature","controlChanges","encodeControlChanges","lastTime","flattenFrom","flattenDown","isArray","flattenFromDepth","depth","TypeError","flattenDownDepth","from","fromDepth","ControlChange_1","ControlChanges_1","Instrument_1","Note_1","createControlChanges","nameEvent","find","Instrument","noteOns","filter","noteOffs","currentNote","offIndex","findIndex","noteOff","this_1","addNote","addCC","props","Note","lastNote","Proxy","target","handler","InstrumentMaps_1","privateTrackMap","programChange","percussion","drumKitByPatchID","instrumentByPatchID","patchNumber","instrumentFamilyByID","includes","family","16","40","48","56","midiToPitchClass","regexp","noteToScaleIndex","pitchToMidi","cbb","cb","c#","cx","dbb","db","d#","dx","ebb","eb","e#","ex","fbb","fb","f","f#","fx","gbb","gb","g","g#","gx","abb","ab","a#","ax","bbb","bb","b#","bx","split","exec","pitch","octave","toLowerCase","parseInt","noteOn","toString","diff","noteEndTicks"],"mappings":"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I,QAEtBgM,EAAAK,oBAAoBvU,KAAKkI,aAIlC,SAAStG,GACR,IAAM4S,EAAcN,EAAAK,oBAAoBhD,QAAQ3P,IAC3B,IAAjB4S,IACHxU,KAAKkI,OAASsM,oCAOhB3T,OAAAC,eAAImS,EAAAlR,UAAA,SAAM,KAAV,WACC,OAAI/B,KAAKqU,WACD,QAEAH,EAAAO,qBAAqBjP,KAAKe,MAAMvG,KAAKkI,OAAS,qCAOvDrH,OAAAC,eAAImS,EAAAlR,UAAA,aAAU,KAAd,WACC,IAAM4G,EAAQwL,EAAgBnT,IAAIhB,MAClC,MAAO,CAAC,EAAG,IAAI0U,SAAS/L,EAAM2C,0CAM/B2H,EAAAlR,UAAA2D,OAAA,WACC,MAAO,CACNiP,OAAS3U,KAAK2U,OACdjU,KAAOV,KAAKU,KACZwH,OAASlI,KAAKkI,SAOhB+K,EAAAlR,UAAA6D,SAAA,SAASC,GACR7F,KAAKkI,OAASrC,EAAKqC,QAErB+K,EA7EA,GAAaxT,EAAAwT,4FCTAxT,EAAA8U,oBAAsB,CAClC,uBACA,wBACA,uBACA,mBACA,mBACA,mBACA,cACA,QACA,UACA,eACA,YACA,aACA,UACA,YACA,gBACA,WACA,gBACA,mBACA,aACA,eACA,aACA,YACA,YACA,kBACA,0BACA,0BACA,yBACA,0BACA,0BACA,oBACA,oBACA,mBACA,gBACA,yBACA,uBACA,gBACA,cACA,cACA,eACA,eACA,SACA,QACA,QACA,aACA,kBACA,oBACA,kBACA,UACA,oBACA,oBACA,iBACA,iBACA,aACA,aACA,cACA,gBACA,UACA,WACA,OACA,gBACA,cACA,gBACA,eACA,eACA,cACA,WACA,YACA,eACA,OACA,eACA,UACA,WACA,UACA,QACA,WACA,YACA,eACA,aACA,UACA,UACA,kBACA,oBACA,oBACA,iBACA,mBACA,iBACA,kBACA,uBACA,kBACA,eACA,oBACA,gBACA,gBACA,mBACA,eACA,gBACA,cACA,oBACA,iBACA,oBACA,oBACA,iBACA,gBACA,gBACA,QACA,QACA,WACA,OACA,UACA,WACA,SACA,SACA,cACA,QACA,cACA,YA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","file":"Midi.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","exports.parseMidi = require('./lib/midi-parser')\nexports.writeMidi = require('./lib/midi-writer')\n","import { MidiData } from \"midi-file\";\nimport { search } from \"./BinarySearch\";\n\nconst privatePPQMap = new WeakMap<Header, number>();\n\nexport interface TempoEvent {\n\tticks: number;\n\tbpm: number;\n\treadonly time?: number;\n}\n\nexport interface TimeSignatureEvent {\n\tticks: number;\n\ttimeSignature: number[];\n\tmeasures?: number;\n}\n\nexport interface MetaEvent {\n\ttext: string;\n\ttype: string;\n\tticks: number;\n}\n\nexport interface KeySignatureEvent {\n\tticks: number;\n\tkey: string;\n\tscale: string;\n}\n\nexport const keySignatureKeys = [\"Cb\", \"Gb\", \"Db\", \"Ab\", \"Eb\", \"Bb\", \"F\", \"C\", \"G\", \"D\", \"A\", \"E\", \"B\", \"F#\", \"C#\"];\n\n/** The parsed midi file header */\nexport class Header {\n\n\t/**\n\t * The array of all the tempo events\n\t */\n\ttempos: TempoEvent[] = [];\n\n\t/**\n\t * The time signatures\n\t */\n\ttimeSignatures: TimeSignatureEvent[] = [];\n\n\t/**\n\t * The time signatures\n\t */\n\tkeySignatures: KeySignatureEvent[] = [];\n\n\t/**\n\t * Additional meta events\n\t */\n\tmeta: MetaEvent[] = [];\n\n\t/**\n\t * The name of the midi file\n\t */\n\tname: string = \"\";\n\n\tconstructor(midiData?: MidiData) {\n\t\t// look through all the tracks for tempo changes\n\n\t\tprivatePPQMap.set(this, 480);\n\n\t\tif (midiData) {\n\t\t\tprivatePPQMap.set(this, midiData.header.ticksPerBeat);\n\t\t\t// check the first track for all the relevant data\n\t\t\tmidiData.tracks[0].forEach(event => {\n\t\t\t\tif (event.meta) {\n\t\t\t\t\tif (event.type === \"timeSignature\") {\n\t\t\t\t\t\tthis.timeSignatures.push({\n\t\t\t\t\t\t\tticks : event.absoluteTime,\n\t\t\t\t\t\t\ttimeSignature : [event.numerator, event.denominator],\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (event.type === \"setTempo\") {\n\t\t\t\t\t\tthis.tempos.push({\n\t\t\t\t\t\t\tbpm : 60000000 / event.microsecondsPerBeat,\n\t\t\t\t\t\t\tticks : event.absoluteTime,\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (event.type === \"keySignature\") {\n\t\t\t\t\t\tthis.keySignatures.push({\n\t\t\t\t\t\t\tkey: keySignatureKeys[event.key + 7],\n\t\t\t\t\t\t\tscale: event.scale === 0 ? \"major\" : \"minor\",\n\t\t\t\t\t\t\tticks: event.absoluteTime,\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (event.type === \"trackName\") {\n\t\t\t\t\t\tthis.name = event.text;\n\t\t\t\t\t} else if (event.type !== \"endOfTrack\") {\n\t\t\t\t\t\tthis.meta.push({\n\t\t\t\t\t\t\ttext: event.text,\n\t\t\t\t\t\t\tticks: event.absoluteTime,\n\t\t\t\t\t\t\ttype: event.type,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.update();\n\t\t}\n\t}\n\n\t/**\n\t * This must be invoked after any changes are made to the tempo array\n\t * or the timeSignature array for the updated values to be reflected.\n\t */\n\tupdate(): void {\n\t\tlet currentTime = 0;\n\t\tlet lastEventBeats = 0;\n\t\t// make sure it's sorted\n\t\tthis.tempos.sort((a, b) => a.ticks - b.ticks);\n\t\tthis.tempos.forEach((event, index) => {\n\t\t\tconst lastBPM = index > 0 ? this.tempos[index - 1].bpm : this.tempos[0].bpm;\n\t\t\tconst beats = (event.ticks / this.ppq) - lastEventBeats;\n\t\t\tconst elapsedSeconds = (60 / lastBPM) * beats;\n\t\t\t// @ts-ignore\n\t\t\tevent.time = elapsedSeconds + currentTime;\n\t\t\tcurrentTime = event.time;\n\t\t\tlastEventBeats += beats;\n\t\t});\n\t\tthis.timeSignatures.sort((a, b) => a.ticks - b.ticks);\n\t\tthis.timeSignatures.forEach((event, index) => {\n\t\t\tconst lastEvent = index > 0 ? this.timeSignatures[index - 1] : this.timeSignatures[0];\n\t\t\tconst elapsedBeats = (event.ticks - lastEvent.ticks) / this.ppq;\n\t\t\tconst elapsedMeasures = (elapsedBeats / lastEvent.timeSignature[0]) / (lastEvent.timeSignature[1] / 4);\n\t\t\tlastEvent.measures = lastEvent.measures || 0;\n\t\t\tevent.measures = elapsedMeasures + lastEvent.measures;\n\t\t});\n\t}\n\n\t/**\n\t * Convert ticks into seconds based on the tempo changes\n\t */\n\tticksToSeconds(ticks: number): number {\n\t\t// find the relevant position\n\t\tconst index = search(this.tempos, ticks);\n\t\tif (index !== -1) {\n\t\t\tconst tempo = this.tempos[index];\n\t\t\tconst tempoTime = tempo.time;\n\t\t\tconst elapsedBeats = (ticks - tempo.ticks) / this.ppq;\n\t\t\treturn tempoTime + (60 / tempo.bpm) * elapsedBeats;\n\t\t} else {\n\t\t\t// assume 120\n\t\t\tconst beats = (ticks / this.ppq);\n\t\t\treturn (60 / 120) * beats;\n\t\t}\n\t}\n\n\t/**\n\t * Convert ticks into measures based off of the time signatures\n\t */\n\tticksToMeasures(ticks: number): number {\n\t\tconst index = search(this.timeSignatures, ticks);\n\t\tif (index !== -1) {\n\t\t\tconst timeSigEvent = this.timeSignatures[index];\n\t\t\tconst elapsedBeats = (ticks - timeSigEvent.ticks) / this.ppq;\n\t\t\treturn timeSigEvent.measures + elapsedBeats / (timeSigEvent.timeSignature[0] / timeSigEvent.timeSignature[1]) / 4;\n\t\t} else {\n\t\t\treturn (ticks / this.ppq) / 4;\n\t\t}\n\t}\n\n\t/**\n\t * The number of ticks per quarter note\n\t */\n\tget ppq(): number {\n\t\treturn privatePPQMap.get(this);\n\t}\n\n\t/**\n\t * Convert seconds to ticks based on the tempo events\n\t */\n\tsecondsToTicks(seconds: number): number {\n\t\t// find the relevant position\n\t\tconst index = search(this.tempos, seconds, \"time\");\n\t\tif (index !== -1) {\n\t\t\tconst tempo = this.tempos[index];\n\t\t\tconst tempoTime = tempo.time;\n\t\t\tconst elapsedTime = (seconds - tempoTime);\n\t\t\tconst elapsedBeats = elapsedTime / (60 / tempo.bpm);\n\t\t\treturn Math.round(tempo.ticks + elapsedBeats * this.ppq);\n\t\t} else {\n\t\t\t// assume 120\n\t\t\tconst beats = seconds / (60 / 120);\n\t\t\treturn Math.round(beats * this.ppq);\n\t\t}\n\t}\n\n\t/**\n\t * Convert the header into an object.\n\t */\n\ttoJSON(): HeaderJSON {\n\t\treturn {\n\t\t\tkeySignatures : this.keySignatures,\n\t\t\tmeta : this.meta,\n\t\t\tname : this.name,\n\t\t\tppq : this.ppq,\n\t\t\ttempos : this.tempos.map(t => {\n\t\t\t\treturn {\n\t\t\t\t\tbpm : t.bpm,\n\t\t\t\t\tticks : t.ticks,\n\t\t\t\t};\n\t\t\t}),\n\t\t\ttimeSignatures : this.timeSignatures,\n\t\t};\n\t}\n\n\t/**\n\t * parse a header json object.\n\t */\n\tfromJSON(json: HeaderJSON): void {\n\t\tthis.name = json.name;\n\t\t// clone all the attributes\n\t\tthis.tempos = json.tempos.map(t => Object.assign({}, t));\n\t\tthis.timeSignatures = json.timeSignatures.map(t => Object.assign({}, t));\n\t\tthis.keySignatures = json.keySignatures.map(t => Object.assign({}, t));\n\t\tthis.meta = json.meta.map(t => Object.assign({}, t));\n\t\tprivatePPQMap.set(this, json.ppq);\n\t\tthis.update();\n\t}\n\n\t/**\n\t * Update the tempo of the midi to a single tempo. Will remove and replace\n\t * any other tempos currently set and update all of the event timing.\n\t * @param bpm The tempo in beats per second\n\t */\n\tsetTempo(bpm: number): void {\n\t\tthis.tempos = [{\n\t\t\tbpm,\n\t\t\tticks: 0,\n\t\t}];\n\t\tthis.update();\n\t}\n}\n\nexport interface HeaderJSON {\n\tname: string;\n\tppq: number;\n\tmeta: MetaEvent[];\n\ttempos: TempoEvent[];\n\ttimeSignatures: TimeSignatureEvent[];\n\tkeySignatures: KeySignatureEvent[];\n}\n","/**\n * Return the index of the element at or before the given property\n */\nexport function search(array: any[], value: any, prop= \"ticks\"): number {\n\tlet beginning = 0;\n\tconst len = array.length;\n\tlet end = len;\n\tif (len > 0 && array[len - 1][prop] <= value) {\n\t\treturn len - 1;\n\t}\n\twhile (beginning < end) {\n\t\t// calculate the midpoint for roughly equal partition\n\t\tlet midPoint = Math.floor(beginning + (end - beginning) / 2);\n\t\tconst event = array[midPoint];\n\t\tconst nextEvent = array[midPoint + 1];\n\t\tif (event[prop] === value) {\n\t\t\t// choose the last one that has the same value\n\t\t\tfor (let i = midPoint; i < array.length; i++) {\n\t\t\t\tconst testEvent = array[i];\n\t\t\t\tif (testEvent[prop] === value) {\n\t\t\t\t\tmidPoint = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn midPoint;\n\t\t} else if (event[prop] < value && nextEvent[prop] > value) {\n\t\t\treturn midPoint;\n\t\t} else if (event[prop] > value) {\n\t\t\t// search lower\n\t\t\tend = midPoint;\n\t\t} else if (event[prop] < value) {\n\t\t\t// search upper\n\t\t\tbeginning = midPoint + 1;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/**\n * Does a binary search to insert the note\n * in the correct spot in the array\n */\nexport function insert(array: any[], event: object, prop: string = \"ticks\"): void {\n\tif (array.length) {\n\t\tconst index = search(array, event[prop], prop);\n\t\tarray.splice(index + 1, 0, event);\n\t} else {\n\t\tarray.push(event);\n\t}\n}\n","import { Header } from \"./Header\";\n\nexport type ControlChangeName =  \"modulationWheel\" | \"breath\" | \"footController\" | \"portamentoTime\"\n\t| \"volume\" | \"balance\" | \"pan\" | \"sustain\" | \"portamentoTime\" | \"sostenuto\" | \"softPedal\"\n\t| \"legatoFootswitch\" | \"portamentoControl\";\n\ninterface ControlChangeMap {\n\t[key: number]: ControlChangeName;\n}\n/**\n * A map of values to control change names\n */\nexport const controlChangeNames: ControlChangeMap = {\n\t1 : \"modulationWheel\",\n\t2 : \"breath\",\n\t4 : \"footController\",\n\t5 : \"portamentoTime\",\n\t7 : \"volume\",\n\t8 : \"balance\",\n\t10 : \"pan\",\n\t64 : \"sustain\",\n\t65 : \"portamentoTime\",\n\t66 : \"sostenuto\",\n\t67 : \"softPedal\",\n\t68 : \"legatoFootswitch\",\n\t84 : \"portamentoControl\",\n};\n\n// swap the keys and values\nexport const controlChangeIds = Object.keys(controlChangeNames).reduce((obj, key) => {\n\tobj[controlChangeNames[key]] = key;\n\treturn obj;\n}, {});\n\nconst privateHeaderMap = new WeakMap<ControlChange, Header>();\nconst privateCCNumberMap = new WeakMap<ControlChange, number>();\n\n/**\n * @typedef ControlChangeEvent\n * @property {number} controllerType\n * @property {number=} value\n * @property {number=} absoluteTime\n */\n\n/**\n * Represents a control change event\n */\nexport class ControlChange implements ControlChangeInterface {\n\n\t/**\n\t * The number value of the event\n\t */\n\tvalue: number;\n\n\t/**\n\t * The tick time of the event\n\t */\n\tticks: number;\n\n\t/**\n\t * @param {ControlChangeEvent} event\n\t * @param {Header} header\n\t */\n\tconstructor(event, header: Header) {\n\t\tprivateHeaderMap.set(this, header);\n\t\tprivateCCNumberMap.set(this, event.controllerType);\n\n\t\tthis.ticks = event.absoluteTime;\n\t\tthis.value = event.value;\n\t}\n\n\t/**\n\t * The controller number\n\t * @readonly\n\t */\n\tget number(): number {\n\t\treturn privateCCNumberMap.get(this);\n\t}\n\n\t/**\n\t * return the common name of the control number if it exists\n\t */\n\tget name(): ControlChangeName {\n\t\tif (controlChangeNames[this.number]) {\n\t\t\treturn controlChangeNames[this.number];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * The time of the event in seconds\n\t */\n\tget time(): number {\n\t\tconst header = privateHeaderMap.get(this);\n\t\treturn header.ticksToSeconds(this.ticks);\n\t}\n\n\tset time(t: number) {\n\t\tconst header = privateHeaderMap.get(this);\n\t\tthis.ticks = header.secondsToTicks(t);\n\t}\n\n\ttoJSON(): ControlChangeJSON {\n\t\treturn {\n\t\t\tnumber : this.number,\n\t\t\tticks : this.ticks,\n\t\t\ttime : this.time,\n\t\t\tvalue : this.value,\n\t\t};\n\t}\n}\n\nexport interface ControlChangeJSON {\n\tnumber: number;\n\tticks: number;\n\ttime: number;\n\tvalue: number;\n}\n\nexport interface ControlChangeInterface {\n\tnumber: number;\n\tticks: number;\n\ttime: number;\n\tvalue: number;\n}\n","import { parseMidi } from \"midi-file\";\nimport { encode } from \"./Encode\";\nimport { Header, HeaderJSON } from \"./Header\";\nimport { Track, TrackJSON } from \"./Track\";\n\n/**\n * The main midi parsing class\n */\nexport class Midi {\n\n\t/**\n\t * Download and parse the MIDI file. Returns a promise\n\t * which resolves to the generated midi file\n\t * @param url The url to fetch\n\t */\n\tstatic async fromUrl(url: string): Promise<Midi> {\n\t\tconst response = await fetch(url);\n\t\tif (response.ok) {\n\t\t\tconst arrayBuffer = await response.arrayBuffer();\n\t\t\treturn new Midi(arrayBuffer);\n\t\t} else {\n\t\t\tthrow new Error(`could not load ${url}`);\n\t\t}\n\t}\n\n\t/**\n\t * The header information, includes things like tempo and meta events.\n\t */\n\theader: Header;\n\n\t/**\n\t * The midi tracks.\n\t */\n\ttracks: Track[];\n\n\t/**\n\t * Parse the midi data\n\t */\n\tconstructor(midiArray?: (ArrayLike<number> | ArrayBuffer)) {\n\n\t\t// parse the midi data if there is any\n\t\tlet midiData = null;\n\t\tif (midiArray) {\n\t\t\tif (midiArray instanceof ArrayBuffer) {\n\t\t\t\tmidiArray = new Uint8Array(midiArray);\n\t\t\t}\n\t\t\tmidiData = parseMidi(midiArray);\n\n\t\t\t// add the absolute times to each of the tracks\n\t\t\tmidiData.tracks.forEach(track => {\n\t\t\t\tlet currentTicks = 0;\n\t\t\t\ttrack.forEach(event => {\n\t\t\t\t\tcurrentTicks += event.deltaTime;\n\t\t\t\t\tevent.absoluteTime = currentTicks;\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\tthis.header = new Header(midiData);\n\t\tthis.tracks = [];\n\n\t\t// parse the midi data\n\t\tif (midiArray) {\n\t\t\t// format 0, everything is on the same track\n\t\t\tthis.tracks = midiData.tracks.map(trackData => new Track(trackData, this.header));\n\n\t\t\t// if it's format 1 and there are no notes on the first track, remove it\n\t\t\tif (midiData.header.format === 1 && this.tracks[0].duration === 0) {\n\t\t\t\tthis.tracks.shift();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The name of the midi file, taken from the first track\n\t */\n\tget name(): string {\n\t\treturn this.header.name;\n\t}\n\n\tset name(n: string) {\n\t\tthis.header.name = n;\n\t}\n\n\t/**\n\t * The total length of the file in seconds\n\t */\n\tget duration(): number {\n\t\t// get the max of the last note of all the tracks\n\t\tconst durations = this.tracks.map(t => t.duration);\n\t\treturn Math.max(...durations);\n\t}\n\n\t/**\n\t * The total length of the file in ticks\n\t */\n\tget durationTicks(): number {\n\t\t// get the max of the last note of all the tracks\n\t\tconst durationTicks = this.tracks.map(t => t.durationTicks);\n\t\treturn Math.max(...durationTicks);\n\t}\n\n\t/**\n\t * Add a track to the midi file\n\t */\n\taddTrack(): Track {\n\t\tconst track = new Track(undefined, this.header);\n\t\tthis.tracks.push(track);\n\t\treturn track;\n\t}\n\n\t/**\n\t * Encode the midi as a Uint8Array.\n\t */\n\ttoArray(): Uint8Array {\n\t\treturn encode(this);\n\t}\n\n\t/**\n\t * Convert the midi object to JSON.\n\t */\n\ttoJSON(): MidiJSON {\n\t\treturn {\n\t\t\theader : this.header.toJSON(),\n\t\t\ttracks : this.tracks.map(track => track.toJSON()),\n\t\t};\n\t}\n\n\t/**\n\t * Parse a JSON representation of the object. Will overwrite the current\n\t * tracks and header.\n\t */\n\tfromJSON(json: MidiJSON): void {\n\t\tthis.header = new Header();\n\t\tthis.header.fromJSON(json.header);\n\t\tthis.tracks = json.tracks.map(trackJSON => {\n\t\t\tconst track = new Track(undefined, this.header);\n\t\t\ttrack.fromJSON(trackJSON);\n\t\t\treturn track;\n\t\t});\n\t}\n\n\t/**\n\t * Clone the entire object midi object\n\t */\n\tclone(): Midi {\n\t\tconst midi = new Midi();\n\t\tmidi.fromJSON(this.toJSON());\n\t\treturn midi;\n\t}\n}\n\n/**\n * The MIDI data in JSON format\n */\ninterface MidiJSON {\n\theader: HeaderJSON;\n\ttracks: TrackJSON[];\n}\n","// data can be any array-like object.  It just needs to support .length, .slice, and an element getter []\n\nfunction parseMidi(data) {\n  var p = new Parser(data)\n\n  var headerChunk = p.readChunk()\n  if (headerChunk.id != 'MThd')\n    throw \"Bad MIDI file.  Expected 'MHdr', got: '\" + headerChunk.id + \"'\"\n  var header = parseHeader(headerChunk.data)\n\n  var tracks = []\n  for (var i=0; !p.eof() && i < header.numTracks; i++) {\n    var trackChunk = p.readChunk()\n    if (trackChunk.id != 'MTrk')\n      throw \"Bad MIDI file.  Expected 'MTrk', got: '\" + trackChunk.id + \"'\"\n    var track = parseTrack(trackChunk.data)\n    tracks.push(track)\n  }\n\n  return {\n    header: header,\n    tracks: tracks\n  }\n}\n\n\nfunction parseHeader(data) {\n  var p = new Parser(data)\n\n  var format = p.readUInt16()\n  var numTracks = p.readUInt16()\n\n  var result = {\n    format: format,\n    numTracks: numTracks\n  }\n\n  var timeDivision = p.readUInt16()\n  if (timeDivision & 0x8000) {\n    result.framesPerSecond = 0x100 - (timeDivision >> 8)\n    result.ticksPerFrame = timeDivision & 0xFF\n  } else {\n    result.ticksPerBeat = timeDivision\n  }\n\n  return result\n}\n\nfunction parseTrack(data) {\n  var p = new Parser(data)\n\n  var events = []\n  while (!p.eof()) {\n    var event = readEvent()\n    events.push(event)\n  }\n\n  return events\n\n  var lastEventTypeByte = null\n\n  function readEvent() {\n    var event = {}\n    event.deltaTime = p.readVarInt()\n\n    var eventTypeByte = p.readUInt8()\n\n    if ((eventTypeByte & 0xf0) === 0xf0) {\n      // system / meta event\n      if (eventTypeByte === 0xff) {\n        // meta event\n        event.meta = true\n        var metatypeByte = p.readUInt8()\n        var length = p.readVarInt()\n        switch (metatypeByte) {\n          case 0x00:\n            event.type = 'sequenceNumber'\n            if (length !== 2) throw \"Expected length for sequenceNumber event is 2, got \" + length\n            event.number = stream.readUInt16()\n            return event\n          case 0x01:\n            event.type = 'text'\n            event.text = p.readString(length)\n            return event\n          case 0x02:\n            event.type = 'copyrightNotice'\n            event.text = p.readString(length)\n            return event\n          case 0x03:\n            event.type = 'trackName'\n            event.text = p.readString(length)\n            return event\n          case 0x04:\n            event.type = 'instrumentName'\n            event.text = p.readString(length)\n            return event\n          case 0x05:\n            event.type = 'lyrics'\n            event.text = p.readString(length)\n            return event\n          case 0x06:\n            event.type = 'marker'\n            event.text = p.readString(length)\n            return event\n          case 0x07:\n            event.type = 'cuePoint'\n            event.text = p.readString(length)\n            return event\n          case 0x20:\n            event.type = 'channelPrefix'\n            if (length != 1) throw \"Expected length for channelPrefix event is 1, got \" + length\n            event.channel = p.readUInt8()\n            return event\n          case 0x21:\n            event.type = 'portPrefix'\n            if (length != 1) throw \"Expected length for portPrefix event is 1, got \" + length\n            event.port = p.readUInt8()\n            return event\n          case 0x2f:\n            event.type = 'endOfTrack'\n            if (length != 0) throw \"Expected length for endOfTrack event is 0, got \" + length\n            return event\n          case 0x51:\n            event.type = 'setTempo';\n            if (length != 3) throw \"Expected length for setTempo event is 3, got \" + length\n            event.microsecondsPerBeat = p.readUInt24()\n            return event\n          case 0x54:\n            event.type = 'smpteOffset';\n            if (length != 5) throw \"Expected length for smpteOffset event is 5, got \" + length\n            var hourByte = p.readUInt8()\n            var FRAME_RATES = { 0x00: 24, 0x20: 25, 0x40: 29, 0x60: 30 }\n            event.frameRate = FRAME_RATES[hourByte & 0x60]\n            event.hour = hourByte & 0x1f\n            event.min = p.readUInt8()\n            event.sec = p.readUInt8()\n            event.frame = p.readUInt8()\n            event.subFrame = p.readUInt8()\n            return event\n          case 0x58:\n            event.type = 'timeSignature'\n            if (length != 4) throw \"Expected length for timeSignature event is 4, got \" + length\n            event.numerator = p.readUInt8()\n            event.denominator = (1 << p.readUInt8())\n            event.metronome = p.readUInt8()\n            event.thirtyseconds = p.readUInt8()\n            return event\n          case 0x59:\n            event.type = 'keySignature'\n            if (length != 2) throw \"Expected length for keySignature event is 2, got \" + length\n            event.key = p.readInt8()\n            event.scale = p.readUInt8()\n            return event\n          case 0x7f:\n            event.type = 'sequencerSpecific'\n            event.data = p.readBytes(length)\n            return event\n          default:\n            event.type = 'unknownMeta'\n            event.data = p.readBytes(length)\n            event.metatypeByte = metatypeByte\n            return event\n        }\n      } else if (eventTypeByte == 0xf0) {\n        event.type = 'sysEx'\n        var length = p.readVarInt()\n        event.data = p.readBytes(length)\n        return event\n      } else if (eventTypeByte == 0xf7) {\n        event.type = 'endSysEx'\n        var length = p.readVarInt()\n        event.data = p.readBytes(length)\n        return event\n      } else {\n        throw \"Unrecognised MIDI event type byte: \" + eventTypeByte\n      }\n    } else {\n      // channel event\n      var param1\n      if ((eventTypeByte & 0x80) === 0) {\n        // running status - reuse lastEventTypeByte as the event type.\n        // eventTypeByte is actually the first parameter\n        if (lastEventTypeByte === null)\n          throw \"Running status byte encountered before status byte\"\n        param1 = eventTypeByte\n        eventTypeByte = lastEventTypeByte\n        event.running = true\n      } else {\n        param1 = p.readUInt8()\n        lastEventTypeByte = eventTypeByte\n      }\n      var eventType = eventTypeByte >> 4\n      event.channel = eventTypeByte & 0x0f\n      switch (eventType) {\n        case 0x08:\n          event.type = 'noteOff'\n          event.noteNumber = param1\n          event.velocity = p.readUInt8()\n          return event\n        case 0x09:\n          var velocity = p.readUInt8()\n          event.type = velocity === 0 ? 'noteOff' : 'noteOn'\n          event.noteNumber = param1\n          event.velocity = velocity\n          if (velocity === 0) event.byte9 = true\n          return event\n        case 0x0a:\n          event.type = 'noteAftertouch'\n          event.noteNumber = param1\n          event.amount = p.readUInt8()\n          return event\n        case 0x0b:\n          event.type = 'controller'\n          event.controllerType = param1\n          event.value = p.readUInt8()\n          return event\n        case 0x0c:\n          event.type = 'programChange'\n          event.programNumber = param1\n          return event\n        case 0x0d:\n          event.type = 'channelAftertouch'\n          event.amount = param1\n          return event\n        case 0x0e:\n          event.type = 'pitchBend'\n          event.value = (param1 + (p.readUInt8() << 7)) - 0x2000\n          return event\n        default:\n          throw \"Unrecognised MIDI event type: \" + eventType\n      }\n    }\n  }\n}\n\nfunction Parser(data) {\n  this.buffer = data\n  this.bufferLen = this.buffer.length\n  this.pos = 0\n}\n\nParser.prototype.eof = function() {\n  return this.pos >= this.bufferLen\n}\n\nParser.prototype.readUInt8 = function() {\n  var result = this.buffer[this.pos]\n  this.pos += 1\n  return result\n}\n\nParser.prototype.readInt8 = function() {\n  var u = this.readUInt8()\n  if (u & 0x80)\n    return u - 0x100\n  else\n    return u\n}\n\nParser.prototype.readUInt16 = function() {\n  var b0 = this.readUInt8(),\n      b1 = this.readUInt8()\n\n    return (b0 << 8) + b1\n}\n\nParser.prototype.readInt16 = function() {\n  var u = this.readUInt16()\n  if (u & 0x8000)\n    return u - 0x10000\n  else\n    return u\n}\n\nParser.prototype.readUInt24 = function() {\n  var b0 = this.readUInt8(),\n      b1 = this.readUInt8(),\n      b2 = this.readUInt8()\n\n    return (b0 << 16) + (b1 << 8) + b2\n}\n\nParser.prototype.readInt24 = function() {\n  var u = this.readUInt24()\n  if (u & 0x800000)\n    return u - 0x1000000\n  else\n    return u\n}\n\nParser.prototype.readUInt32 = function() {\n  var b0 = this.readUInt8(),\n      b1 = this.readUInt8(),\n      b2 = this.readUInt8(),\n      b3 = this.readUInt8()\n\n    return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3\n}\n\nParser.prototype.readBytes = function(len) {\n  var bytes = this.buffer.slice(this.pos, this.pos + len)\n  this.pos += len\n  return bytes\n}\n\nParser.prototype.readString = function(len) {\n  var bytes = this.readBytes(len)\n  return String.fromCharCode.apply(null, bytes)\n}\n\nParser.prototype.readVarInt = function() {\n  var result = 0\n  while (!this.eof()) {\n    var b = this.readUInt8()\n    if (b & 0x80) {\n      result += (b & 0x7f)\n      result <<= 7\n    } else {\n      // b is last byte\n      return result + b\n    }\n  }\n  // premature eof\n  return result\n}\n\nParser.prototype.readChunk = function() {\n  var id = this.readString(4)\n  var length = this.readUInt32()\n  var data = this.readBytes(length)\n  return {\n    id: id,\n    length: length,\n    data: data\n  }\n}\n\nmodule.exports = parseMidi\n","// data should be the same type of format returned by parseMidi\n// for maximum compatibililty, returns an array of byte values, suitable for conversion to Buffer, Uint8Array, etc.\n\n// opts:\n// - running              reuse previous eventTypeByte when possible, to compress file\n// - useByte9ForNoteOff   use 0x09 for noteOff when velocity is zero\n\nfunction writeMidi(data, opts) {\n  if (typeof data !== 'object')\n    throw 'Invalid MIDI data'\n\n  opts = opts || {}\n\n  var header = data.header || {}\n  var tracks = data.tracks || []\n  var i, len = tracks.length\n\n  var w = new Writer()\n  writeHeader(w, header, len)\n\n  for (i=0; i < len; i++) {\n    writeTrack(w, tracks[i], opts)\n  }\n\n  return w.buffer\n}\n\nfunction writeHeader(w, header, numTracks) {\n  var format = header.format == null ? 1 : header.format\n\n  var timeDivision = 128\n  if (header.timeDivision) {\n    timeDivision = header.timeDivision\n  } else if (header.ticksPerFrame && header.framesPerSecond) {\n    timeDivision = (-(header.framesPerSecond & 0xFF) << 8) | (ticksPerFrame & 0xFF)\n  } else if (header.ticksPerBeat) {\n    timeDivision = header.ticksPerBeat & 0x7FFF\n  }\n\n  var h = new Writer()\n  h.writeUInt16(format)\n  h.writeUInt16(numTracks)\n  h.writeUInt16(timeDivision)\n\n  w.writeChunk('MThd', h.buffer)\n}\n\nfunction writeTrack(w, track, opts) {\n  var t = new Writer()\n  var i, len = track.length\n  var eventTypeByte = null\n  for (i=0; i < len; i++) {\n    // Reuse last eventTypeByte when opts.running is set, or event.running is explicitly set on it.\n    // parseMidi will set event.running for each event, so that we can get an exact copy by default.\n    // Explicitly set opts.running to false, to override event.running and never reuse last eventTypeByte.\n    if (opts.running === false || !opts.running && !track[i].running) eventTypeByte = null\n\n    eventTypeByte = writeEvent(t, track[i], eventTypeByte, opts.useByte9ForNoteOff)\n  }\n  w.writeChunk('MTrk', t.buffer)\n}\n\nfunction writeEvent(w, event, lastEventTypeByte, useByte9ForNoteOff) {\n  var type = event.type\n  var deltaTime = event.deltaTime\n  var text = event.text || ''\n  var data = event.data || []\n  var eventTypeByte = null\n  w.writeVarInt(deltaTime)\n\n  switch (type) {\n    // meta events\n    case 'sequenceNumber':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x00)\n      w.writeVarInt(2)\n      w.writeUInt16(event.number)\n      break;\n\n    case 'text':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x01)\n      w.writeVarInt(text.length)\n      w.writeString(text)\n      break;\n\n    case 'copyrightNotice':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x02)\n      w.writeVarInt(text.length)\n      w.writeString(text)\n      break;\n\n    case 'trackName':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x03)\n      w.writeVarInt(text.length)\n      w.writeString(text)\n      break;\n\n    case 'instrumentName':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x04)\n      w.writeVarInt(text.length)\n      w.writeString(text)\n      break;\n\n    case 'lyrics':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x05)\n      w.writeVarInt(text.length)\n      w.writeString(text)\n      break;\n\n    case 'marker':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x06)\n      w.writeVarInt(text.length)\n      w.writeString(text)\n      break;\n\n    case 'cuePoint':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x07)\n      w.writeVarInt(text.length)\n      w.writeString(text)\n      break;\n\n    case 'channelPrefix':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x20)\n      w.writeVarInt(1)\n      w.writeUInt8(event.channel)\n      break;\n\n    case 'portPrefix':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x21)\n      w.writeVarInt(1)\n      w.writeUInt8(event.port)\n      break;\n\n    case 'endOfTrack':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x2F)\n      w.writeVarInt(0)\n      break;\n\n    case 'setTempo':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x51)\n      w.writeVarInt(3)\n      w.writeUInt24(event.microsecondsPerBeat)\n      break;\n\n    case 'smpteOffset':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x54)\n      w.writeVarInt(5)\n      var FRAME_RATES = { 24: 0x00, 25: 0x20, 29: 0x40, 30: 0x60 }\n      var hourByte = (event.hour & 0x1F) | FRAME_RATES[event.frameRate]\n      w.writeUInt8(hourByte)\n      w.writeUInt8(event.min)\n      w.writeUInt8(event.sec)\n      w.writeUInt8(event.frame)\n      w.writeUInt8(event.subFrame)\n      break;\n\n    case 'timeSignature':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x58)\n      w.writeVarInt(4)\n      w.writeUInt8(event.numerator)\n      var denominator = Math.floor((Math.log(event.denominator) / Math.LN2)) & 0xFF\n      w.writeUInt8(denominator)\n      w.writeUInt8(event.metronome)\n      w.writeUInt8(event.thirtyseconds || 8)\n      break;\n\n    case 'keySignature':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x59)\n      w.writeVarInt(2)\n      w.writeInt8(event.key)\n      w.writeUInt8(event.scale)\n      break;\n\n    case 'sequencerSpecific':\n      w.writeUInt8(0xFF)\n      w.writeUInt8(0x7F)\n      w.writeVarInt(data.length)\n      w.writeBytes(data)\n      break;\n\n    case 'unknownMeta':\n      if (event.metatypeByte != null) {\n        w.writeUInt8(0xFF)\n        w.writeUInt8(event.metatypeByte)\n        w.writeVarInt(data.length)\n        w.writeBytes(data)\n      }\n      break;\n\n    // system-exclusive\n    case 'sysEx':\n      w.writeUInt8(0xF0)\n      w.writeVarInt(data.length)\n      w.writeBytes(data)\n      break;\n\n    case 'endSysEx':\n      w.writeUInt8(0xF7)\n      w.writeVarInt(data.length)\n      w.writeBytes(data)\n      break;\n\n    // channel events\n    case 'noteOff':\n      // Use 0x90 when opts.useByte9ForNoteOff is set and velocity is zero, or when event.byte9 is explicitly set on it.\n      // parseMidi will set event.byte9 for each event, so that we can get an exact copy by default.\n      // Explicitly set opts.useByte9ForNoteOff to false, to override event.byte9 and always use 0x80 for noteOff events.\n      var noteByte = ((useByte9ForNoteOff !== false && event.byte9) || (useByte9ForNoteOff && event.velocity == 0)) ? 0x90 : 0x80\n\n      eventTypeByte = noteByte | event.channel\n      if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte)\n      w.writeUInt8(event.noteNumber)\n      w.writeUInt8(event.velocity)\n      break;\n\n    case 'noteOn':\n      eventTypeByte = 0x90 | event.channel\n      if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte)\n      w.writeUInt8(event.noteNumber)\n      w.writeUInt8(event.velocity)\n      break;\n\n    case 'noteAftertouch':\n      eventTypeByte = 0xA0 | event.channel\n      if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte)\n      w.writeUInt8(event.noteNumber)\n      w.writeUInt8(event.amount)\n      break;\n\n    case 'controller':\n      eventTypeByte = 0xB0 | event.channel\n      if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte)\n      w.writeUInt8(event.controllerType)\n      w.writeUInt8(event.value)\n      break;\n\n    case 'programChange':\n      eventTypeByte = 0xC0 | event.channel\n      if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte)\n      w.writeUInt8(event.programNumber)\n      break;\n\n    case 'channelAftertouch':\n      eventTypeByte = 0xD0 | event.channel\n      if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte)\n      w.writeUInt8(event.amount)\n      break;\n\n    case 'pitchBend':\n      eventTypeByte = 0xE0 | event.channel\n      if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte)\n      var value14 = 0x2000 + event.value\n      var lsb14 = (value14 & 0x7F)\n      var msb14 = (value14 >> 7) & 0x7F\n      w.writeUInt8(lsb14)\n      w.writeUInt8(msb14)\n    break;\n\n    default:\n      throw 'Unrecognized event type: ' + type\n  }\n  return eventTypeByte\n}\n\n\nfunction Writer() {\n  this.buffer = []\n}\n\nWriter.prototype.writeUInt8 = function(v) {\n  this.buffer.push(v & 0xFF)\n}\nWriter.prototype.writeInt8 = Writer.prototype.writeUInt8\n\nWriter.prototype.writeUInt16 = function(v) {\n  var b0 = (v >> 8) & 0xFF,\n      b1 = v & 0xFF\n\n  this.writeUInt8(b0)\n  this.writeUInt8(b1)\n}\nWriter.prototype.writeInt16 = Writer.prototype.writeUInt16\n\nWriter.prototype.writeUInt24 = function(v) {\n  var b0 = (v >> 16) & 0xFF,\n      b1 = (v >> 8) & 0xFF,\n      b2 = v & 0xFF\n\n  this.writeUInt8(b0)\n  this.writeUInt8(b1)\n  this.writeUInt8(b2)\n}\nWriter.prototype.writeInt24 = Writer.prototype.writeUInt24\n\nWriter.prototype.writeUInt32 = function(v) {\n  var b0 = (v >> 24) & 0xFF,\n      b1 = (v >> 16) & 0xFF,\n      b2 = (v >> 8) & 0xFF,\n      b3 = v & 0xFF\n\n  this.writeUInt8(b0)\n  this.writeUInt8(b1)\n  this.writeUInt8(b2)\n  this.writeUInt8(b3)\n}\nWriter.prototype.writeInt32 = Writer.prototype.writeUInt32\n\n\nWriter.prototype.writeBytes = function(arr) {\n  this.buffer = this.buffer.concat(Array.prototype.slice.call(arr, 0))\n}\n\nWriter.prototype.writeString = function(str) {\n  var i, len = str.length, arr = []\n  for (i=0; i < len; i++) {\n    arr.push(str.codePointAt(i))\n  }\n  this.writeBytes(arr)\n}\n\nWriter.prototype.writeVarInt = function(v) {\n  if (v < 0) throw \"Cannot write negative variable-length integer\"\n\n  if (v <= 0x7F) {\n    this.writeUInt8(v)\n  } else {\n    var i = v\n    var bytes = []\n    bytes.push(i & 0x7F)\n    i >>= 7\n    while (i) {\n      var b = i & 0x7F | 0x80\n      bytes.push(b)\n      i >>= 7\n    }\n    this.writeBytes(bytes.reverse())\n  }\n}\n\nWriter.prototype.writeChunk = function(id, data) {\n  this.writeString(id)\n  this.writeUInt32(data.length)\n  this.writeBytes(data)\n}\n\nmodule.exports = writeMidi\n","import { writeMidi } from \"midi-file\";\nimport { MidiControllerEvent, MidiData, MidiEndOfTrackEvent,\n\tMidiInstrumentEvent, MidiKeySignatureEvent, MidiNoteOffEvent,\n\tMidiNoteOnEvent, MidiTempoEvent, MidiTextEvent, MidiTimeSignatureEvent, MidiTrackNameEvent } from \"midi-file\";\nimport { ControlChange } from \"./ControlChange\";\nimport { KeySignatureEvent, keySignatureKeys, MetaEvent, TempoEvent, TimeSignatureEvent } from \"./Header\";\nimport { Midi } from \"./Midi\";\nimport { Note } from \"./Note\";\nimport { Track } from \"./Track\";\n// tslint:disable-next-line: no-var-requires\nconst flatten = require(\"array-flatten\");\n\nfunction encodeNote(note: Note, channel: number): [MidiNoteOnEvent, MidiNoteOffEvent] {\n\treturn [{\n\t\tabsoluteTime: note.ticks,\n\t\tchannel,\n\t\tdeltaTime: 0,\n\t\tnoteNumber: note.midi,\n\t\ttype: \"noteOn\",\n\t\tvelocity: Math.floor(note.velocity * 127),\n\t},\n\t{\n\t\tabsoluteTime: note.ticks + note.durationTicks,\n\t\tchannel,\n\t\tdeltaTime: 0,\n\t\tnoteNumber: note.midi,\n\t\ttype: \"noteOff\",\n\t\tvelocity: Math.floor(note.noteOffVelocity * 127),\n\t}];\n}\n\nfunction encodeNotes(track: Track): Array<MidiNoteOnEvent | MidiNoteOffEvent> {\n\treturn flatten(track.notes.map(note => encodeNote(note, track.channel)));\n}\n\nfunction encodeControlChange(cc: ControlChange, channel: number): MidiControllerEvent {\n\treturn {\n\t\tabsoluteTime: cc.ticks,\n\t\tchannel,\n\t\tcontrollerType: cc.number,\n\t\tdeltaTime: 0,\n\t\ttype: \"controller\",\n\t\tvalue: cc.value,\n\t};\n}\n\nfunction encodeControlChanges(track: Track): MidiControllerEvent[] {\n\tconst controlChanges: MidiControllerEvent[] = [];\n\tfor (let i = 0; i < 127; i++) {\n\t\tif (track.controlChanges.hasOwnProperty(i)) {\n\t\t\ttrack.controlChanges[i].forEach((cc: ControlChange) => {\n\t\t\t\tcontrolChanges.push(encodeControlChange(cc, track.channel));\n\t\t\t});\n\t\t}\n\t}\n\treturn controlChanges;\n}\n\nfunction encodeInstrument(track: Track): MidiInstrumentEvent {\n\treturn {\n\t\tabsoluteTime: 0,\n\t\tchannel: track.channel,\n\t\tdeltaTime: 0,\n\t\tprogramNumber: track.instrument.number,\n\t\ttype: \"programChange\",\n\t};\n}\n\nfunction encodeTrackName(name: string): MidiTrackNameEvent {\n\treturn {\n\t\tabsoluteTime: 0,\n\t\tdeltaTime: 0,\n\t\tmeta: true,\n\t\ttext: name,\n\t\ttype: \"trackName\",\n\t};\n}\n\nfunction encodeTempo(tempo: TempoEvent): MidiTempoEvent {\n\treturn {\n\t\tabsoluteTime: tempo.ticks,\n\t\tdeltaTime: 0,\n\t\tmeta: true,\n\t\tmicrosecondsPerBeat: Math.floor(60000000 / tempo.bpm),\n\t\ttype: \"setTempo\",\n\t};\n}\n\nfunction encodeTimeSignature(timeSig: TimeSignatureEvent): MidiTimeSignatureEvent {\n\treturn {\n\t\tabsoluteTime: timeSig.ticks,\n\t\tdeltaTime: 0,\n\t\tdenominator: timeSig.timeSignature[1],\n\t\tmeta: true,\n\t\tmetronome: 24,\n\t\tnumerator: timeSig.timeSignature[0],\n\t\tthirtyseconds: 8,\n\t\ttype: \"timeSignature\",\n\t};\n}\n\n// function encodeMeta(event: )\n\nfunction encodeKeySignature(keySig: KeySignatureEvent): MidiKeySignatureEvent {\n\tconst keyIndex = keySignatureKeys.indexOf(keySig.key);\n\treturn {\n\t\tabsoluteTime: keySig.ticks,\n\t\tdeltaTime: 0,\n\t\tkey: keyIndex + 7,\n\t\tmeta: true,\n\t\tscale: keySig.scale === \"major\" ? 0 : 1,\n\t\ttype: \"keySignature\",\n\t};\n}\n\nfunction encodeText(textEvent: MetaEvent): MidiTextEvent {\n\treturn {\n\t\tabsoluteTime: textEvent.ticks,\n\t\tdeltaTime: 0,\n\t\tmeta: true,\n\t\ttext: textEvent.text,\n\t\ttype: textEvent.type,\n\t} as MidiTextEvent;\n}\n\n/**\n * Convert the midi object to an array\n */\nexport function encode(midi: Midi): Uint8Array {\n\tconst midiData: MidiData = {\n\t\theader : {\n\t\t\tformat : 1,\n\t\t\tnumTracks : midi.tracks.length + 1,\n\t\t\tticksPerBeat : midi.header.ppq,\n\t\t},\n\t\ttracks : [\n\t\t\t[\n\t\t\t\t// the name data\n\t\t\t\t{\n\t\t\t\t\tabsoluteTime: 0,\n\t\t\t\t\tdeltaTime: 0,\n\t\t\t\t\tmeta : true,\n\t\t\t\t\ttext : midi.header.name,\n\t\t\t\t\ttype : \"trackName\",\n\t\t\t\t} as MidiTrackNameEvent,\n\t\t\t\t...midi.header.keySignatures.map(keySig => encodeKeySignature(keySig)),\n\t\t\t\t// and all the meta events (cloned for safety)\n\t\t\t\t...midi.header.meta.map(e => encodeText(e)),\n\t\t\t\t// the first track is all the tempo data\n\t\t\t\t...midi.header.tempos.map(tempo => encodeTempo(tempo)),\n\t\t\t\t// and the time signature data\n\t\t\t\t...midi.header.timeSignatures.map(timeSig => encodeTimeSignature(timeSig)),\n\t\t\t],\n\t\t\t// the remaining tracks\n\t\t\t...midi.tracks.map(track => {\n\t\t\t\treturn [\n\t\t\t\t\t// add the name\n\t\t\t\t\tencodeTrackName(track.name),\n\t\t\t\t\t// the instrument\n\t\t\t\t\tencodeInstrument(track),\n\t\t\t\t\t// add the notes\n\t\t\t\t\t...encodeNotes(track),\n\t\t\t\t\t// and the control changes\n\t\t\t\t\t...encodeControlChanges(track),\n\t\t\t\t];\n\t\t\t}),\n\t\t],\n\t};\n\n\t// sort and set deltaTime of all of the tracks\n\tmidiData.tracks = midiData.tracks.map(track => {\n\t\ttrack = track.sort((a, b) => a.absoluteTime - b.absoluteTime);\n\t\tlet lastTime = 0;\n\t\ttrack.forEach(note => {\n\t\t\tnote.deltaTime = note.absoluteTime - lastTime;\n\t\t\tlastTime = note.absoluteTime;\n\t\t\tdelete note.absoluteTime;\n\t\t});\n\t\t// end of track\n\t\ttrack.push({\n\t\t\tdeltaTime : 0,\n\t\t\tmeta : true,\n\t\t\ttype : \"endOfTrack\",\n\t\t} as MidiEndOfTrackEvent);\n\t\treturn track;\n\t});\n\n\t// return midiData\n\treturn new Uint8Array(writeMidi(midiData));\n}\n","'use strict'\n\n/**\n * Expose `arrayFlatten`.\n */\nmodule.exports = flatten\nmodule.exports.from = flattenFrom\nmodule.exports.depth = flattenDepth\nmodule.exports.fromDepth = flattenFromDepth\n\n/**\n * Flatten an array.\n *\n * @param  {Array} array\n * @return {Array}\n */\nfunction flatten (array) {\n  if (!Array.isArray(array)) {\n    throw new TypeError('Expected value to be an array')\n  }\n\n  return flattenFrom(array)\n}\n\n/**\n * Flatten an array-like structure.\n *\n * @param  {Array} array\n * @return {Array}\n */\nfunction flattenFrom (array) {\n  return flattenDown(array, [])\n}\n\n/**\n * Flatten an array-like structure with depth.\n *\n * @param  {Array}  array\n * @param  {number} depth\n * @return {Array}\n */\nfunction flattenDepth (array, depth) {\n  if (!Array.isArray(array)) {\n    throw new TypeError('Expected value to be an array')\n  }\n\n  return flattenFromDepth(array, depth)\n}\n\n/**\n * Flatten an array-like structure with depth.\n *\n * @param  {Array}  array\n * @param  {number} depth\n * @return {Array}\n */\nfunction flattenFromDepth (array, depth) {\n  if (typeof depth !== 'number') {\n    throw new TypeError('Expected the depth to be a number')\n  }\n\n  return flattenDownDepth(array, [], depth)\n}\n\n/**\n * Flatten an array indefinitely.\n *\n * @param  {Array} array\n * @param  {Array} result\n * @return {Array}\n */\nfunction flattenDown (array, result) {\n  for (var i = 0; i < array.length; i++) {\n    var value = array[i]\n\n    if (Array.isArray(value)) {\n      flattenDown(value, result)\n    } else {\n      result.push(value)\n    }\n  }\n\n  return result\n}\n\n/**\n * Flatten an array with depth.\n *\n * @param  {Array}  array\n * @param  {Array}  result\n * @param  {number} depth\n * @return {Array}\n */\nfunction flattenDownDepth (array, result, depth) {\n  depth--\n\n  for (var i = 0; i < array.length; i++) {\n    var value = array[i]\n\n    if (depth > -1 && Array.isArray(value)) {\n      flattenDownDepth(value, result, depth)\n    } else {\n      result.push(value)\n    }\n  }\n\n  return result\n}\n","import { MidiControllerEvent, MidiNoteOffEvent, MidiNoteOnEvent, MidiTrackData, MidiTrackNameEvent } from \"midi-file\";\nimport { insert } from \"./BinarySearch\";\nimport { ControlChange, ControlChangeInterface } from \"./ControlChange\";\nimport { ControlChangesJSON, createControlChanges } from \"./ControlChanges\";\nimport { Header } from \"./Header\";\nimport { Instrument, InstrumentJSON } from \"./Instrument\";\nimport { Note, NoteInterface, NoteJSON } from \"./Note\";\n\nconst privateHeaderMap = new WeakMap<Track, Header>();\n\n/**\n * A Track is a collection of notes and controlChanges\n */\nexport class Track {\n\n\t/**\n\t * The name of the track\n\t */\n\tname: string = \"\";\n\n\t/**\n\t * The instrument associated with the track\n\t */\n\tinstrument: Instrument;\n\n\t/**\n\t * The track's note events\n\t */\n\tnotes: Note[] = [];\n\n\t/**\n\t * The channel number of the track. Applies this channel\n\t * to all events associated with the channel\n\t */\n\tchannel: number;\n\n\t/**\n\t * The control change events\n\t */\n\tcontrolChanges = createControlChanges();\n\n\tconstructor(trackData: MidiTrackData, header: Header) {\n\n\t\tprivateHeaderMap.set(this, header);\n\n\t\tif (trackData) {\n\t\t\tconst nameEvent = trackData.find(e => e.type === \"trackName\") as MidiTrackNameEvent;\n\t\t\tthis.name = nameEvent ? nameEvent.text : \"\";\n\t\t}\n\n\t\t/** @type {Instrument} */\n\t\tthis.instrument = new Instrument(trackData, this);\n\n\t\tthis.channel = 0;\n\n\t\tif (trackData) {\n\t\t\tconst noteOns = trackData.filter(event => event.type === \"noteOn\") as MidiNoteOnEvent[];\n\t\t\tconst noteOffs = trackData.filter(event => event.type === \"noteOff\") as MidiNoteOffEvent[];\n\t\t\twhile (noteOns.length) {\n\t\t\t\tconst currentNote = noteOns.shift();\n\t\t\t\t// find the corresponding note off\n\t\t\t\tconst offIndex = noteOffs.findIndex(note => note.noteNumber === currentNote.noteNumber);\n\t\t\t\tif (offIndex !== -1) {\n\t\t\t\t\t// once it's got the note off, add it\n\t\t\t\t\tconst noteOff = noteOffs.splice(offIndex, 1)[0];\n\t\t\t\t\tthis.addNote({\n\t\t\t\t\t\tdurationTicks : noteOff.absoluteTime - currentNote.absoluteTime,\n\t\t\t\t\t\tmidi : currentNote.noteNumber,\n\t\t\t\t\t\tnoteOffVelocity : noteOff.velocity / 127,\n\t\t\t\t\t\tticks : currentNote.absoluteTime,\n\t\t\t\t\t\tvelocity : currentNote.velocity / 127,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst controlChanges = trackData.filter(event => event.type === \"controller\") as MidiControllerEvent[];\n\t\t\tcontrolChanges.forEach(event => {\n\t\t\t\tthis.addCC({\n\t\t\t\t\tnumber : event.controllerType,\n\t\t\t\t\tticks : event.absoluteTime,\n\t\t\t\t\tvalue : event.value / 127,\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t// const endOfTrack = trackData.find(event => event.type === \"endOfTrack\");\n\t\t}\n\t}\n\n\t/**\n\t * Add a note to the notes array\n\t * @param props The note properties to add\n\t */\n\taddNote(props: Partial<NoteInterface> = {}): this {\n\t\tconst header = privateHeaderMap.get(this);\n\t\tconst note = new Note({\n\t\t\tmidi : 0,\n\t\t\tticks : 0,\n\t\t\tvelocity : 1,\n\t\t}, {\n\t\t\tticks : 0,\n\t\t\tvelocity : 0,\n\t\t}, header);\n\t\tObject.assign(note, props);\n\t\tinsert(this.notes, note, \"ticks\");\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a control change to the track\n\t * @param props\n\t */\n\taddCC(props: Partial<ControlChangeInterface>): this {\n\t\tconst header = privateHeaderMap.get(this);\n\t\tconst cc = new ControlChange({\n\t\t\tcontrollerType : props.number,\n\t\t}, header);\n\t\tdelete props.number;\n\t\tObject.assign(cc, props);\n\t\tif (!Array.isArray(this.controlChanges[cc.number])) {\n\t\t\tthis.controlChanges[cc.number] = [];\n\t\t}\n\t\tinsert(this.controlChanges[cc.number], cc, \"ticks\");\n\t\treturn this;\n\t}\n\n\t/**\n\t * The end time of the last event in the track\n\t */\n\tget duration(): number {\n\t\tconst lastNote = this.notes[this.notes.length - 1];\n\t\tif (lastNote) {\n\t\t\treturn lastNote.time + lastNote.duration;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The end time of the last event in the track in ticks\n\t */\n\tget durationTicks(): number {\n\t\tconst lastNote = this.notes[this.notes.length - 1];\n\t\tif (lastNote) {\n\t\t\treturn lastNote.ticks + lastNote.durationTicks;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * Assign the json values to this track\n\t */\n\tfromJSON(json: TrackJSON): void {\n\t\tthis.name = json.name;\n\t\tthis.channel = json.channel;\n\t\tthis.instrument = new Instrument(undefined, this);\n\t\tthis.instrument.fromJSON(json.instrument);\n\t\tfor (const number in json.controlChanges) {\n\t\t\tif (json.controlChanges[number]) {\n\t\t\t\tjson.controlChanges[number].forEach(cc => {\n\t\t\t\t\tthis.addCC({\n\t\t\t\t\t\tnumber : cc.number,\n\t\t\t\t\t\tticks : cc.ticks,\n\t\t\t\t\t\tvalue : cc.value,\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tjson.notes.forEach(n => {\n\t\t\tthis.addNote({\n\t\t\t\tdurationTicks : n.durationTicks,\n\t\t\t\tmidi : n.midi,\n\t\t\t\tticks : n.ticks,\n\t\t\t\tvelocity : n.velocity,\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Convert the track into a JSON format\n\t */\n\ttoJSON(): TrackJSON {\n\n\t\t// convert all the CCs to JSON\n\t\tconst controlChanges = {};\n\t\tfor (let i = 0; i < 127; i++) {\n\t\t\tif (this.controlChanges.hasOwnProperty(i)) {\n\t\t\t\tcontrolChanges[i] = this.controlChanges[i].map(c => c.toJSON());\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tchannel : this.channel,\n\t\t\tcontrolChanges,\n\t\t\tinstrument : this.instrument.toJSON(),\n\t\t\tname : this.name,\n\t\t\tnotes : this.notes.map(n => n.toJSON()),\n\t\t};\n\t}\n}\n\nexport interface TrackJSON {\n\tname: string;\n\tnotes: NoteJSON[];\n\tchannel: number;\n\tinstrument: InstrumentJSON;\n\tcontrolChanges: ControlChangesJSON;\n}\n","import { controlChangeIds } from \"./ControlChange\";\nimport { ControlChange, ControlChangeJSON } from \"./ControlChange\";\n\nexport interface ControlChanges {\n\t[key: string]: ControlChange[];\n\t[key: number]: ControlChange[];\n}\n\nexport interface ControlChangesJSON {\n\t[key: string]: ControlChangeJSON[];\n\t[key: number]: ControlChangeJSON[];\n}\n\n/**\n * Automatically creates an alias for named control values using Proxies\n */\nexport function createControlChanges(): ControlChanges {\n\treturn new Proxy({}, {\n\t\t// tslint:disable-next-line: typedef\n\t\tget(target, handler) {\n\t\t\tif (target[handler]) {\n\t\t\t\treturn target[handler];\n\t\t\t} else if (controlChangeIds.hasOwnProperty(handler)) {\n\t\t\t\treturn target[controlChangeIds[handler]];\n\t\t\t}\n\t\t},\n\t\t// tslint:disable-next-line: typedef\n\t\tset(target, handler, value) {\n\t\t\tif (controlChangeIds.hasOwnProperty(handler)) {\n\t\t\t\ttarget[controlChangeIds[handler]] = value;\n\t\t\t} else {\n\t\t\t\ttarget[handler] = value;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t});\n}\n","import { MidiInstrumentEvent, MidiTrackData } from \"midi-file\";\nimport { drumKitByPatchID, instrumentByPatchID, instrumentFamilyByID } from \"./InstrumentMaps\";\nimport { Track } from \"./Track\";\n\nconst privateTrackMap = new WeakMap<Instrument, Track>();\n\n/**\n * Describes the midi instrument of a track\n */\nexport class Instrument {\n\n\t/**\n\t * The instrument number\n\t */\n\tnumber: number = 0;\n\n\t/**\n\t * @param {Array} [trackData]\n\t * @param {Track} track\n\t */\n\tconstructor(trackData: MidiTrackData, track) {\n\n\t\tprivateTrackMap.set(this, track);\n\t\tthis.number = 0;\n\t\tif (trackData) {\n\t\t\tconst programChange = trackData.find(e => e.type === \"programChange\") as MidiInstrumentEvent;\n\t\t\tif (programChange) {\n\t\t\t\tthis.number = programChange.programNumber;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The common name of the instrument\n\t */\n\tget name(): string {\n\t\tif (this.percussion) {\n\t\t\treturn drumKitByPatchID[this.number];\n\t\t} else {\n\t\t\treturn instrumentByPatchID[this.number];\n\t\t}\n\t}\n\n\tset name(n: string) {\n\t\tconst patchNumber = instrumentByPatchID.indexOf(n);\n\t\tif (patchNumber !== -1) {\n\t\t\tthis.number = patchNumber;\n\t\t}\n\t}\n\n\t/**\n\t * The instrument family, e.g. \"piano\".\n\t */\n\tget family(): string {\n\t\tif (this.percussion) {\n\t\t\treturn \"drums\";\n\t\t} else {\n\t\t\treturn instrumentFamilyByID[Math.floor(this.number / 8)];\n\t\t}\n\t}\n\n\t/**\n\t * If the instrument is a percussion instrument\n\t */\n\tget percussion(): boolean {\n\t\tconst track = privateTrackMap.get(this);\n\t\treturn [9, 10].includes(track.channel);\n\t}\n\n\t/**\n\t * Convert it to JSON form\n\t */\n\ttoJSON(): InstrumentJSON {\n\t\treturn {\n\t\t\tfamily : this.family,\n\t\t\tname : this.name,\n\t\t\tnumber : this.number,\n\t\t};\n\t}\n\n\t/**\n\t * Convert from JSON form\n\t */\n\tfromJSON(json: InstrumentJSON): void {\n\t\tthis.number = json.number;\n\t}\n}\n\nexport interface InstrumentJSON {\n\tnumber: number;\n\tname: string;\n\tfamily: string;\n}\n","export const instrumentByPatchID = [\n\t\"acoustic grand piano\",\n\t\"bright acoustic piano\",\n\t\"electric grand piano\",\n\t\"honky-tonk piano\",\n\t\"electric piano 1\",\n\t\"electric piano 2\",\n\t\"harpsichord\",\n\t\"clavi\",\n\t\"celesta\",\n\t\"glockenspiel\",\n\t\"music box\",\n\t\"vibraphone\",\n\t\"marimba\",\n\t\"xylophone\",\n\t\"tubular bells\",\n\t\"dulcimer\",\n\t\"drawbar organ\",\n\t\"percussive organ\",\n\t\"rock organ\",\n\t\"church organ\",\n\t\"reed organ\",\n\t\"accordion\",\n\t\"harmonica\",\n\t\"tango accordion\",\n\t\"acoustic guitar (nylon)\",\n\t\"acoustic guitar (steel)\",\n\t\"electric guitar (jazz)\",\n\t\"electric guitar (clean)\",\n\t\"electric guitar (muted)\",\n\t\"overdriven guitar\",\n\t\"distortion guitar\",\n\t\"guitar harmonics\",\n\t\"acoustic bass\",\n\t\"electric bass (finger)\",\n\t\"electric bass (pick)\",\n\t\"fretless bass\",\n\t\"slap bass 1\",\n\t\"slap bass 2\",\n\t\"synth bass 1\",\n\t\"synth bass 2\",\n\t\"violin\",\n\t\"viola\",\n\t\"cello\",\n\t\"contrabass\",\n\t\"tremolo strings\",\n\t\"pizzicato strings\",\n\t\"orchestral harp\",\n\t\"timpani\",\n\t\"string ensemble 1\",\n\t\"string ensemble 2\",\n\t\"synthstrings 1\",\n\t\"synthstrings 2\",\n\t\"choir aahs\",\n\t\"voice oohs\",\n\t\"synth voice\",\n\t\"orchestra hit\",\n\t\"trumpet\",\n\t\"trombone\",\n\t\"tuba\",\n\t\"muted trumpet\",\n\t\"french horn\",\n\t\"brass section\",\n\t\"synthbrass 1\",\n\t\"synthbrass 2\",\n\t\"soprano sax\",\n\t\"alto sax\",\n\t\"tenor sax\",\n\t\"baritone sax\",\n\t\"oboe\",\n\t\"english horn\",\n\t\"bassoon\",\n\t\"clarinet\",\n\t\"piccolo\",\n\t\"flute\",\n\t\"recorder\",\n\t\"pan flute\",\n\t\"blown bottle\",\n\t\"shakuhachi\",\n\t\"whistle\",\n\t\"ocarina\",\n\t\"lead 1 (square)\",\n\t\"lead 2 (sawtooth)\",\n\t\"lead 3 (calliope)\",\n\t\"lead 4 (chiff)\",\n\t\"lead 5 (charang)\",\n\t\"lead 6 (voice)\",\n\t\"lead 7 (fifths)\",\n\t\"lead 8 (bass + lead)\",\n\t\"pad 1 (new age)\",\n\t\"pad 2 (warm)\",\n\t\"pad 3 (polysynth)\",\n\t\"pad 4 (choir)\",\n\t\"pad 5 (bowed)\",\n\t\"pad 6 (metallic)\",\n\t\"pad 7 (halo)\",\n\t\"pad 8 (sweep)\",\n\t\"fx 1 (rain)\",\n\t\"fx 2 (soundtrack)\",\n\t\"fx 3 (crystal)\",\n\t\"fx 4 (atmosphere)\",\n\t\"fx 5 (brightness)\",\n\t\"fx 6 (goblins)\",\n\t\"fx 7 (echoes)\",\n\t\"fx 8 (sci-fi)\",\n\t\"sitar\",\n\t\"banjo\",\n\t\"shamisen\",\n\t\"koto\",\n\t\"kalimba\",\n\t\"bag pipe\",\n\t\"fiddle\",\n\t\"shanai\",\n\t\"tinkle bell\",\n\t\"agogo\",\n\t\"steel drums\",\n\t\"woodblock\",\n\t\"taiko drum\",\n\t\"melodic tom\",\n\t\"synth drum\",\n\t\"reverse cymbal\",\n\t\"guitar fret noise\",\n\t\"breath noise\",\n\t\"seashore\",\n\t\"bird tweet\",\n\t\"telephone ring\",\n\t\"helicopter\",\n\t\"applause\",\n\t\"gunshot\",\n];\n\nexport const instrumentFamilyByID = [\n\t\"piano\",\n\t\"chromatic percussion\",\n\t\"organ\",\n\t\"guitar\",\n\t\"bass\",\n\t\"strings\",\n\t\"ensemble\",\n\t\"brass\",\n\t\"reed\",\n\t\"pipe\",\n\t\"synth lead\",\n\t\"synth pad\",\n\t\"synth effects\",\n\t\"world\",\n\t\"percussive\",\n\t\"sound effects\",\n];\n\nexport const drumKitByPatchID = {\n\t0 : \"standard kit\",\n\t8 : \"room kit\",\n\t16 : \"power kit\",\n\t24 : \"electronic kit\",\n\t25 : \"tr-808 kit\",\n\t32 : \"jazz kit\",\n\t40 : \"brush kit\",\n\t48 : \"orchestra kit\",\n\t56 : \"sound fx kit\",\n};\n","import { MidiNoteEvent } from \"midi-file\";\nimport { Header } from \"./Header\";\n\n/**\n * Convert a midi note into a pitch\n */\nfunction midiToPitch(midi: number): string {\n\tconst octave = Math.floor(midi / 12) - 1;\n\treturn midiToPitchClass(midi) + octave.toString();\n}\n\n/**\n * Convert a midi note to a pitch class (just the pitch no octave)\n */\nfunction midiToPitchClass(midi: number): string {\n\tconst scaleIndexToNote = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\n\tconst note = midi % 12;\n\treturn scaleIndexToNote[note];\n}\n\n/**\n * Convert a pitch class to a MIDI note\n */\nfunction pitchClassToMidi(pitch: string): number {\n\tconst scaleIndexToNote = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\n\treturn scaleIndexToNote.indexOf(pitch);\n}\n\n/**\n * Convert a pitch to a midi number\n */\n// tslint:disable-next-line: only-arrow-functions typedef\nconst pitchToMidi: (note: string) => number = (function() {\n\tconst regexp = /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i;\n\tconst noteToScaleIndex = {\n\t\t// tslint:disable-next-line: object-literal-sort-keys\n\t\t\"cbb\" : -2, \"cb\" : -1, \"c\" : 0, \"c#\" : 1, \"cx\" : 2,\n\t\t\"dbb\" : 0, \"db\" : 1, \"d\" : 2, \"d#\" : 3, \"dx\" : 4,\n\t\t\"ebb\" : 2, \"eb\" : 3, \"e\" : 4, \"e#\" : 5, \"ex\" : 6,\n\t\t\"fbb\" : 3, \"fb\" : 4, \"f\" : 5, \"f#\" : 6, \"fx\" : 7,\n\t\t\"gbb\" : 5, \"gb\" : 6, \"g\" : 7, \"g#\" : 8, \"gx\" : 9,\n\t\t\"abb\" : 7, \"ab\" : 8, \"a\" : 9, \"a#\" : 10, \"ax\" : 11,\n\t\t\"bbb\" : 9, \"bb\" : 10, \"b\" : 11, \"b#\" : 12, \"bx\" : 13,\n\t};\n\treturn (note) => {\n\t\tconst split = regexp.exec(note);\n\t\tconst pitch = split[1];\n\t\tconst octave = split[2];\n\t\tconst index = noteToScaleIndex[pitch.toLowerCase()];\n\t\treturn index + (parseInt(octave, 10) + 1) * 12;\n\t};\n}());\n\nconst privateHeaderMap = new WeakMap<Note, Header>();\n\n/**\n * A Note consists of a noteOn and noteOff event\n */\nexport class Note implements NoteInterface {\n\n\t/**\n\t * The notes midi value\n\t */\n\tmidi: number;\n\n\t/**\n\t * The normalized velocity (0-1)\n\t */\n\tvelocity: number;\n\n\t/**\n\t * The velocity of the note off\n\t */\n\tnoteOffVelocity: number;\n\n\t/**\n\t * The start time in ticks\n\t */\n\tticks: number;\n\n\t/**\n\t * The duration in ticks\n\t */\n\tdurationTicks: number;\n\n\tconstructor(noteOn: NoteOnEvent, noteOff: NoteOffEvent, header: Header) {\n\n\t\tprivateHeaderMap.set(this, header);\n\n\t\tthis.midi = noteOn.midi;\n\n\t\tthis.velocity = noteOn.velocity;\n\n\t\tthis.noteOffVelocity = noteOff.velocity;\n\n\t\tthis.ticks = noteOn.ticks;\n\n\t\tthis.durationTicks = noteOff.ticks - noteOn.ticks;\n\t}\n\n\t/**\n\t * The note name and octave in scientific pitch notation, e.g. \"C4\"\n\t */\n\tget name(): string {\n\t\treturn midiToPitch(this.midi);\n\t}\n\n\tset name(n: string) {\n\t\tthis.midi = pitchToMidi(n);\n\t}\n\n\t/**\n\t * The notes octave number\n\t */\n\tget octave(): number {\n\t\treturn Math.floor(this.midi / 12) - 1;\n\t}\n\n\tset octave(o: number) {\n\t\tconst diff = o - this.octave;\n\t\tthis.midi += diff * 12;\n\t}\n\n\t/**\n\t * The pitch class name. e.g. \"A\"\n\t */\n\tget pitch(): string {\n\t\treturn midiToPitchClass(this.midi);\n\t}\n\n\tset pitch(p: string) {\n\t\tthis.midi = 12 * (this.octave + 1) + pitchClassToMidi(p);\n\t}\n\n\t/**\n\t * The duration of the segment in seconds\n\t */\n\tget duration(): number {\n\t\tconst header = privateHeaderMap.get(this);\n\t\treturn header.ticksToSeconds(this.ticks + this.durationTicks) - header.ticksToSeconds(this.ticks);\n\t}\n\n\tset duration(d: number) {\n\t\tconst header = privateHeaderMap.get(this);\n\t\tconst noteEndTicks = header.secondsToTicks(this.time + d);\n\t\tthis.durationTicks = noteEndTicks - this.ticks;\n\t}\n\n\t/**\n\t * The time of the event in seconds\n\t */\n\tget time(): number {\n\t\tconst header = privateHeaderMap.get(this);\n\t\treturn header.ticksToSeconds(this.ticks);\n\t}\n\n\tset time(t: number) {\n\t\tconst header = privateHeaderMap.get(this);\n\t\tthis.ticks = header.secondsToTicks(t);\n\t}\n\n\t/**\n\t * The number of measures (and partial measures) to this beat.\n\t * Takes into account time signature changes\n\t * @readonly\n\t */\n\tget bars(): number {\n\t\tconst header = privateHeaderMap.get(this);\n\t\treturn header.ticksToMeasures(this.ticks);\n\t}\n\n\ttoJSON(): NoteJSON {\n\t\treturn {\n\t\t\tduration : this.duration,\n\t\t\tdurationTicks : this.durationTicks,\n\t\t\tmidi : this.midi,\n\t\t\tname : this.name,\n\t\t\tticks : this.ticks,\n\t\t\ttime : this.time,\n\t\t\tvelocity : this.velocity,\n\t\t};\n\t}\n}\n\nexport interface NoteJSON {\n\ttime: number;\n\tmidi: number;\n\tname: string;\n\tvelocity: number;\n\tduration: number;\n\tticks: number;\n\tdurationTicks: number;\n}\n\nexport interface NoteOnEvent {\n\tticks: number;\n\tvelocity: number;\n\tmidi: number;\n}\n\nexport interface NoteOffEvent {\n\tticks: number;\n\tvelocity: number;\n}\n\nexport interface NoteInterface {\n\ttime: number;\n\tticks: number;\n\tduration: number;\n\tdurationTicks: number;\n\tmidi: number;\n\tpitch: string;\n\toctave: number;\n\tname: string;\n\tnoteOffVelocity: number;\n\tvelocity: number;\n}\n"],"sourceRoot":""}